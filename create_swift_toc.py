# This script is intended for use in intermediate doc repos generated from docs.ms CI.
# Given a reference ToC and a set of namespaces, limit the reference to ToC entries that contain
# namespaces in our set.

import argparse
import pdb
import os
import fnmatch
import re
import json

# by default, yaml does not maintain insertion order of the dicts
# given that this is intended to generate TABLE OF CONTENTS values,
# maintaining this order is important.
# The drop-in replacement oyaml is a handy solution for us.
import oyaml as yaml

## template
# for each file/member found in HOME.md
created_name = "{}" # name
created_uid = "azure.swift.sdk.landingPage.services.{}.{}" # service, member name
created_href: "~/docs-ref-services/swift-gen/{}/{}.md" # service, member name

root_dir = os.path.abspath(os.path.join(os.path.abspath(__file__), ".."))
source_md = os.path.join(root_dir, "seed_reference.yml")
target_md = os.path.join(root_dir, "docs-ref-mapping", "reference.yml")

targeted_services = ["core","storage"]
operators = ["",""]

def filter_children(targeted_ns_list, known_namespaces):
    amended_list = []

    for ns in targeted_ns_list:
        # also need to handle when the namespace grep is a pattern
        # azure-eventhubs* <-- for instance
        if any(
            [
                re.match(fnmatch.translate(ns), known_namespace)
                for known_namespace in known_namespaces
            ]
        ):
            amended_list.append(ns)

    return amended_list

# the doc builds have the capability to reference readmes from external repos (they resolve during publishing)
# this means that we can't simply check the href values for existence. If they are an href that STARTS with one of the
# "dependent repositories" than we should leave them exactly as is.
# amend_href is the core of the logic for handling referenced files and ensures that we cannot refer to the same readme twice
# from two different reference ymls
def amend_href(toc_dict, repo_location, readme_suffix, excluded_href_paths):
    suffix = "-" + readme_suffix + ".md" if readme_suffix else  ".md"
    input_string = toc_dict["href"]

    # if this is an external readme, we should not attempt to resolve the file to a different one, just return with no changes
    if any([input_string.startswith(href) for href in excluded_href_paths]):
        return toc_dict 

    resolvable_path = os.path.join(repo_location, input_string.replace("~/", ""))
    possible_target_readme = os.path.splitext(resolvable_path)[0] + suffix

    if os.path.exists(possible_target_readme):
        toc_dict["href"] = input_string.replace(".md", suffix)
    else:
        toc_dict.pop("href")
        toc_dict["landingPageType"] = "Service"

    return toc_dict

# a post-order recursive function that returns a modified reference.yml
# based on the set of namespaces that we've grabbed from autogenerated ToC.yml
def filter_toc(toc_dict, namespaces, repo_location, readme_suffix="", excluded_href_paths = []):
    if toc_dict is None:
        return None

    # internal node
    if "items" in toc_dict:
        # recurse as mant times as necessary
        item_list = []
        for item in toc_dict["items"]:
            result_n = filter_toc(item, namespaces, repo_location, readme_suffix, excluded_href_paths)
            # only append the result if we know it exists
            if result_n:
                item_list.append(result_n)
        if item_list:
            toc_dict["items"] = item_list
        else:
            return None

    # handle href
    if "href" in toc_dict and repo_location:
        toc_dict = amend_href(toc_dict, repo_location, readme_suffix, excluded_href_paths)

    # leaf node
    if "children" in toc_dict:
        filtered_children = filter_children(toc_dict["children"], namespaces)
        # if we filter out all the children, this node should simply cease to exist
        if not filtered_children:
            return None

    # always amend the uid to include the suffix if one is present.
    if "uid" in toc_dict and readme_suffix:
        toc_dict["uid"] = toc_dict["uid"] + "." + readme_suffix

    return toc_dict

def grep_children_namespaces(autogenerated_toc_yml):
    return [
        top_level_namespace["name"] for top_level_namespace in autogenerated_toc_yml
    ] + ["*"]

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="""
      Creates a reference.yml from swift-generated markdown documentation.
      """
    )

    # parser.add_argument("-r", "--reference", help="The source ToC.yml", required=True)

    # parser.add_argument("-t", "--target", help="The target ToC.yml", required=True)

    # parser.add_argument(
    #     "-n",
    #     "--namespaces",
    #     help="The ToC.yml where target autogenerated documentation exists",
    #     required=True,
    # )

    # parser.add_argument(
    #     "-d",
    #     "--docrepo",
    #     help="The root directory of the target documentation repository.",
    #     required=True,
    # )

    # parser.add_argument(
    #     "-s",
    #     "--suffix",
    #     help="If possible, find readmes with this suffix.",
    #     default="",
    #     required=False,
    # # )

    # args = parser.parse_args()

    # load seed YML
    try:
        with open(source_md, "r") as reference_yml:
            base_reference_toc = yaml.safe_load(reference_yml)

        # with open(target_md, "r") as target_autogenerated_toc_yml:
        #     target_autogenerated_toc = yaml.safe_load(target_autogenerated_toc_yml)
    except Exception as f:
        print(f)
        exit(1)

    print(base_reference_toc)
